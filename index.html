<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Chroma-Snake</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        :root {
            --screen-bg: #9bbc0f; /* Classic Gameboy Green */
            --screen-dark: #0f380f;
        }
        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Press Start 2P', cursive;
        }
        canvas { display: block; width: 100%; height: 100%;}

        /* --- UI Overlay (PC Only) --- */
        .ui-overlay {
            position: absolute;
            top: 0; left: 0; right: 0;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            font-size: clamp(0.8rem, 2.5vw, 1.2rem);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            color: #FFFFFF;
        }

        /* --- Mobile Phone Layout --- */
        .mobile-wrapper {
            display: none; /* Hidden by default */
            width: 100%; height: 100%;
            /* NEW, STABLE IMAGE URL */
            background-image: url('https://i.imgur.com/GgS43Ue.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            position: relative;
        }
       /* Add this new code starting at line 49 */
.mobile-wrapper {
    display: none; 
    width: 100%; height: 100%;
    background-color: #333;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 10px;
    box-sizing: border-box;
}
.mobile-canvas-container {
    flex-grow: 1; /* Game screen takes available space */
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    padding-bottom: 20px;
}
.mobile-controls {
    width: 100%;
    max-width: 300px;
    display: grid;
    grid-template-areas:
        ". up ."
        "left center right"
        ". down .";
    grid-gap: 10px;
}
.touch-btn {
    background-color: #555;
    border: 2px solid #777;
    border-radius: 10px;
    cursor: pointer;
    aspect-ratio: 1 / 1; /* Makes buttons square */
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2rem;
    color: #ccc;
    -webkit-tap-highlight-color: rgba(255,255,255,0.2);
}
.touch-btn:active {
    background-color: #777;
}
        .modal {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            z-index: 10;
        }
        .modal h1 {
            font-size: clamp(2rem, 10vw, 3rem); margin-bottom: 20px; color: #FFD300;
            text-shadow: 3px 3px 0px #BC00DD;
        }
        .modal p { font-size: 1.5rem; margin: 20px 0; color: #FFFFFF; }
        .button {
            padding: 15px 30px; font-size: 1.5rem; font-family: 'Press Start 2P', cursive;
            color: #FFFFFF; background-color: #00F9B8; border: 3px solid #FFFFFF;
            cursor: pointer; box-shadow: 5px 5px 0px #FF5470; transition: all 0.1s ease-in-out;
            margin: 10px;
        }
        .button:active { transform: translate(5px, 5px); box-shadow: none; }
    </style>
</head>
<body>

<!-- Add this new code starting at line 128 -->
<div id="mobileWrapper" class="mobile-wrapper">
    <div class="mobile-canvas-container">
        <canvas id="mobileGameCanvas"></canvas>
    </div>
    <div class="mobile-controls">
        <div id="btn-up" class="touch-btn">▲</div>
        <div id="btn-down" class="touch-btn">▼</div>
        <div id="btn-left" class="touch-btn">◄</div>
        <div id="btn-right" class="touch-btn">►</div>
    </div>
</div>

<div id="pcContainer" class="pc-container">
    <canvas id="gameCanvas"></canvas>
    <div class="ui-overlay">
        <div id="score">SCORE: 0</div> <div id="highScore">HIGH: 0</div>
    </div>
</div>

<div id="deviceChoiceScreen" class="modal">
    <h1>Chroma-Snake</h1>
    <p>Choose your device</p>
    <div>
        <button id="pcButton" class="button">PC</button>
        <button id="mobileButton" class="button">Mobile</button>
    </div>
</div>

<div id="gameOverScreen" class="modal" style="display: none;">
    <h1>Game Over</h1>
    <p id="finalScore"></p>
    <button id="playAgainButton" class="button">Play Again</button>
</div>

<script>
    // --- Global Setup ---
    let canvas, ctx, scoreEl, highScoreEl, isMobile;
    const deviceChoiceScreen = document.getElementById('deviceChoiceScreen');
    const pcButton = document.getElementById('pcButton');
    const mobileButton = document.getElementById('mobileButton');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScoreEl = document.getElementById('finalScore');
    const playAgainButton = document.getElementById('playAgainButton');

    // --- Game Constants ---
    const COLORS = ["#FFD300", "#FF5470", "#4D94FF", "#00F9B8", "#BC00DD", "#FFFFFF"];
    const INITIAL_SPEED = 200;
    const SPEED_INCREMENT = 3;
    const BIG_FOOD_THRESHOLD = 5;
    let TILE_SIZE, GRID_WIDTH, GRID_HEIGHT;

    // --- Game State ---
    let snake, food, bigFood, isBigFoodActive, foodEatenCount, score, highScore, direction, nextDirection, isGameOver, gameLoopTimeout, currentSpeed;
    highScore = localStorage.getItem('chromaSnakeHighScore') || 0;

    // --- Sound & Haptics ---
    let synth, crashSynth, soundsReady = false;
    function setupAudio() {
        if (typeof Tone !== 'undefined' && !soundsReady) {
            if (Tone.context.state !== 'running') {
                Tone.context.resume();
            }
            synth = new Tone.Synth({ oscillator: { type: 'sine' } }).toDestination();
            crashSynth = new Tone.NoiseSynth({ envelope: { attack: 0.01, decay: 0.2 } }).toDestination();
            soundsReady = true;
        }
    }
    function playEatSound() { if (soundsReady) synth.triggerAttackRelease('C5', '8n'); }
    function playGameOverSound() { if (soundsReady) crashSynth.triggerAttackRelease('4n'); }
    function triggerVibration(duration) {
        if (isMobile && 'vibrate' in navigator) navigator.vibrate(duration);
    }

    // --- Device Selection ---
    pcButton.addEventListener('click', () => setupGame(false));
    mobileButton.addEventListener('click', () => setupGame(true));
    
    function setupGame(mobile) {
        isMobile = mobile;
        setupAudio(); // Initialize audio on first user interaction
        deviceChoiceScreen.style.display = 'none';

        if (isMobile) {
            document.body.style.backgroundColor = '#000'; // Black background for mobile
            document.getElementById('mobileWrapper').style.display = 'block';
            canvas = document.getElementById('mobileGameCanvas');
            TILE_SIZE = Math.floor(canvas.parentElement.clientWidth / 20); // Dynamic tile size
            GRID_WIDTH = 20; GRID_HEIGHT = 20;
        } else {
            document.body.style.backgroundColor = '#1a2531';
            const container = document.getElementById('pcContainer');
            container.style.display = 'flex';
            container.style.justifyContent = 'center';
            container.style.alignItems = 'center';
            container.style.width = '100%';
            container.style.height = '100%';

            canvas = document.getElementById('gameCanvas');
            scoreEl = document.getElementById('score');
            highScoreEl = document.getElementById('highScore');
            TILE_SIZE = 20; GRID_WIDTH = 30; GRID_HEIGHT = 20;
        }
        ctx = canvas.getContext('2d');
        canvas.width = GRID_WIDTH * TILE_SIZE;
        canvas.height = GRID_HEIGHT * TILE_SIZE;
        init();
    }

    // --- Game Initialization ---
    function init() {
        snake = [{ x: 10, y: 10 }, { x: 9, y: 10 }, { x: 8, y: 10 }];
        snake.color = isMobile ? 'var(--screen-dark)' : COLORS[Math.floor(Math.random() * COLORS.length)];
        score = 0;
        direction = 'RIGHT'; nextDirection = 'RIGHT';
        isGameOver = false; isBigFoodActive = false; foodEatenCount = 0;
        currentSpeed = INITIAL_SPEED;

        spawnFood();
        updateScores();
        gameOverScreen.style.display = 'none';

        if (gameLoopTimeout) clearTimeout(gameLoopTimeout);
        gameLoop();
    }

    // --- Main Game Loop ---
    function gameLoop() {
        if (isGameOver) return;
        update();
        draw();
        gameLoopTimeout = setTimeout(gameLoop, currentSpeed);
    }
    
    // --- Drawing ---
    function draw() {
        ctx.fillStyle = isMobile ? 'var(--screen-bg)' : '#2C3E50';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // --- Draw Food (now as circles) ---
        const foodFillStyle = isMobile ? 'var(--screen-dark)' : food.color;
        ctx.fillStyle = foodFillStyle;
        ctx.beginPath();
        ctx.arc(food.x * TILE_SIZE + TILE_SIZE / 2, food.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 2, 0, 2 * Math.PI);
        ctx.fill();

        // --- Draw Big Food (now as a bigger circle) ---
        if (isBigFoodActive) {
            const bigFoodFillStyle = isMobile ? 'var(--screen-dark)' : bigFood.color;
            ctx.fillStyle = bigFoodFillStyle;
            ctx.beginPath();
            ctx.arc(bigFood.x * TILE_SIZE + TILE_SIZE, bigFood.y * TILE_SIZE + TILE_SIZE, TILE_SIZE, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        isMobile ? drawMobileSnake() : drawPCSnake();
    }

    function drawMobileSnake() {
        ctx.fillStyle = snake.color;
        snake.forEach(segment => {
            ctx.fillRect(segment.x * TILE_SIZE, segment.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        });
    }

    function drawPCSnake() {
        // Draw body segments
        for (let i = snake.length - 1; i > 0; i--) {
            const segment = snake[i];
            const prevSegment = snake[i - 1];
            const maxRadius = TILE_SIZE / 2 * 1.1;
            const minRadius = TILE_SIZE / 4;
            const radius = Math.max(maxRadius - (i / snake.length) * (maxRadius - minRadius), minRadius);
            
            ctx.beginPath();
            ctx.moveTo(segment.x * TILE_SIZE + TILE_SIZE / 2, segment.y * TILE_SIZE + TILE_SIZE / 2);
            ctx.lineTo(prevSegment.x * TILE_SIZE + TILE_SIZE / 2, prevSegment.y * TILE_SIZE + TILE_SIZE / 2);
            ctx.strokeStyle = snake.color;
            ctx.lineWidth = radius * 2;
            ctx.lineCap = 'round';
            ctx.stroke();
        }
        
        // Draw head
        const head = snake[0];
        const headRadius = (TILE_SIZE / 2 * 1.1);
        ctx.fillStyle = snake.color;
        ctx.beginPath();
        ctx.arc(head.x * TILE_SIZE + TILE_SIZE / 2, head.y * TILE_SIZE + TILE_SIZE / 2, headRadius, 0, 2 * Math.PI);
        ctx.fill();

        // Draw eyes
        const eyeRadius = TILE_SIZE / 10;
        const eyeOffset = TILE_SIZE / 4;
        let eye1_x, eye1_y, eye2_x, eye2_y;
        const headCenterX = head.x * TILE_SIZE + TILE_SIZE / 2;
        const headCenterY = head.y * TILE_SIZE + TILE_SIZE / 2;

        switch(direction) {
            case 'RIGHT': eye1_x = headCenterX + eyeOffset / 2; eye1_y = headCenterY - eyeOffset; eye2_x = headCenterX + eyeOffset / 2; eye2_y = headCenterY + eyeOffset; break;
            case 'LEFT': eye1_x = headCenterX - eyeOffset / 2; eye1_y = headCenterY - eyeOffset; eye2_x = headCenterX - eyeOffset / 2; eye2_y = headCenterY + eyeOffset; break;
            case 'UP': eye1_x = headCenterX - eyeOffset; eye1_y = headCenterY - eyeOffset / 2; eye2_x = headCenterX + eyeOffset; eye2_y = headCenterY - eyeOffset / 2; break;
            case 'DOWN': eye1_x = headCenterX - eyeOffset; eye1_y = headCenterY + eyeOffset / 2; eye2_x = headCenterX + eyeOffset; eye2_y = headCenterY + eyeOffset / 2; break;
        }
        ctx.fillStyle = '#1a2531';
        ctx.beginPath(); ctx.arc(eye1_x, eye1_y, eyeRadius, 0, 2 * Math.PI); ctx.fill();
        ctx.beginPath(); ctx.arc(eye2_x, eye2_y, eyeRadius, 0, 2 * Math.PI); ctx.fill();
    }

    // --- Game Logic Update ---
    function update() {
        direction = nextDirection;
        const head = { x: snake[0].x, y: snake[0].y };
        switch (direction) {
            case 'UP': head.y--; break; case 'DOWN': head.y++; break;
            case 'LEFT': head.x--; break; case 'RIGHT': head.x++; break;
        }
        if (head.x < 0 || head.x >= GRID_WIDTH || head.y < 0 || head.y >= GRID_HEIGHT || snake.some(seg => seg.x === head.x && seg.y === head.y)) {
            triggerVibration([100, 50, 100]); endGame(); return;
        }
        snake.unshift(head);
        if (isBigFoodActive && head.x >= bigFood.x && head.x < bigFood.x + 2 && head.y >= bigFood.y && head.y < bigFood.y + 2) {
            score += 50;
            for (let i = 0; i < 5; i++) snake.push({ ...snake[snake.length - 1] });
            isBigFoodActive = false; foodEatenCount = 0;
            if(!isMobile) snake.color = bigFood.color;
            currentSpeed = Math.max(50, currentSpeed - SPEED_INCREMENT);
            playEatSound(); triggerVibration(100); spawnFood();
        } else if (head.x === food.x && head.y === food.y) {
            score += 10;
            if (!isMobile) snake.color = food.color;
            foodEatenCount++;
            if (isBigFoodActive) { isBigFoodActive = false; foodEatenCount = 0; }
            if (foodEatenCount >= BIG_FOOD_THRESHOLD) { isBigFoodActive = true; spawnBigFood(); }
            currentSpeed = Math.max(50, currentSpeed - SPEED_INCREMENT);
            playEatSound(); triggerVibration(50); spawnFood();
        } else {
            snake.pop();
        }
        updateScores();
    }

    // --- Utilities ---
    function spawnFood() {
        let position;
        do { position = { x: Math.floor(Math.random() * GRID_WIDTH), y: Math.floor(Math.random() * GRID_HEIGHT) };
        } while (snake.some(seg => seg.x === position.x && seg.y === position.y));
        food = { ...position, color: COLORS[Math.floor(Math.random() * COLORS.length)] };
    }
    function spawnBigFood() {
        let position;
        do { position = { x: Math.floor(Math.random() * (GRID_WIDTH - 1)), y: Math.floor(Math.random() * (GRID_HEIGHT - 1)) };
        } while (snake.some(seg => seg.x >= position.x && seg.x < position.x + 2 && seg.y >= position.y && seg.y < position.y + 2) || (position.x === food.x && position.y === food.y));
        bigFood = { ...position, color: COLORS[Math.floor(Math.random() * COLORS.length)] };
    }
    function updateScores() {
        if (isMobile) return;
        scoreEl.textContent = `SCORE: ${score}`;
        if (score > highScore) { highScore = score; localStorage.setItem('chromaSnakeHighScore', highScore); }
        highScoreEl.textContent = `HIGH: ${highScore}`;
    }
    function endGame() {
        isGameOver = true;
        playGameOverSound();
        const finalHighScore = Math.max(score, highScore);
        finalScoreEl.textContent = `Score: ${score} | High: ${finalHighScore}`;
        gameOverScreen.style.display = 'flex';
    }
    function handleInput(newDirection) {
        if (isGameOver) return;
        const opposite = { 'UP': 'DOWN', 'DOWN': 'UP', 'LEFT': 'RIGHT', 'RIGHT': 'LEFT' };
        if (direction !== opposite[newDirection]) nextDirection = newDirection;
    }

    // --- Input Listeners ---
    document.addEventListener('keydown', e => { if(isMobile) return; switch (e.key) { case 'ArrowUp': handleInput('UP'); break; case 'ArrowDown': handleInput('DOWN'); break; case 'ArrowLeft': handleInput('LEFT'); break; case 'ArrowRight': handleInput('RIGHT'); break; } });
    document.getElementById('btn-up').addEventListener('click', () => handleInput('UP'));
    document.getElementById('btn-down').addEventListener('click', () => handleInput('DOWN'));
    document.getElementById('btn-left').addEventListener('click', () => handleInput('LEFT'));
    document.getElementById('btn-right').addEventListener('click', () => handleInput('RIGHT'));
    playAgainButton.addEventListener('click', init);
</script>

</body>
</html>


