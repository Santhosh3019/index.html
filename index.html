<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chroma-Snake</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #1a2531;
            font-family: 'Press Start 2P', cursive;
            color: #FFFFFF;
            overflow: hidden;
        }
        .game-container {
            position: relative;
            border: 4px solid #FFFFFF;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            background-color: #2C3E50;
        }
        canvas {
            display: block;
            background-color: #2C3E50;
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            font-size: 1.2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(44, 62, 80, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            z-index: 10;
        }
        .modal h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            color: #FFD300; /* Cyber Yellow */
            text-shadow: 3px 3px 0px #BC00DD; /* Electric Purple shadow */
        }
        .modal p {
            font-size: 1.5rem;
            margin-top: 0;
        }
        .button {
            padding: 15px 30px;
            font-size: 1.5rem;
            font-family: 'Press Start 2P', cursive;
            color: #FFFFFF;
            background-color: #00F9B8; /* Emerald Green */
            border: 3px solid #FFFFFF;
            cursor: pointer;
            box-shadow: 5px 5px 0px #FF5470; /* Fiery Rose shadow */
            transition: all 0.1s ease-in-out;
        }
        .button:hover {
            transform: translate(2px, 2px);
            box-shadow: 3px 3px 0px #FF5470;
        }
        .button:active {
            transform: translate(5px, 5px);
            box-shadow: none;
        }
    </style>
</head>
<body>

<div id="gameContainer" class="game-container">
    <div class="ui-overlay">
        <div id="score">SCORE: 0</div>
        <div id="highScore">HIGH: 0</div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="startScreen" class="modal">
        <h1>Chroma-Snake</h1>
        <button id="startButton" class="button">Start Game</button>
    </div>
    <div id="gameOverScreen" class="modal" style="display: none;">
        <h1>Game Over</h1>
        <p id="finalScore"></p>
        <button id="playAgainButton" class="button">Play Again</button>
    </div>
</div>

<script>
    // --- Basic Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const TILE_SIZE = 20;
    const GRID_WIDTH = 30;
    const GRID_HEIGHT = 20;

    canvas.width = GRID_WIDTH * TILE_SIZE;
    canvas.height = GRID_HEIGHT * TILE_SIZE;

    // --- UI Elements ---
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('highScore');
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const startButton = document.getElementById('startButton');
    const playAgainButton = document.getElementById('playAgainButton');
    const finalScoreEl = document.getElementById('finalScore');

    // --- Game Constants ---
    const COLORS = ["#FFD300", "#FF5470", "#4D94FF", "#00F9B8", "#BC00DD", "#FFFFFF"];
    const INITIAL_SPEED = 200; // ms per update
    const SPEED_INCREMENT = 2; // ms faster per food item

    // --- Game State Variables ---
    let snake;
    let food;
    let score;
    let highScore = localStorage.getItem('chromaSnakeHighScore') || 0;
    let direction;
    let nextDirection;
    let isGameOver;
    let gameLoopTimeout;
    let currentSpeed;

    // --- Sound Synthesis ---
    let synth, crashSynth;
    let soundsReady = false;

    // Initialize sounds after Tone.js is ready
    if (typeof Tone !== 'undefined') {
        synth = new Tone.Synth({
            oscillator: { type: 'sine' },
            envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.1 }
        }).toDestination();

        crashSynth = new Tone.NoiseSynth({
            noise: { type: 'white' },
            envelope: { attack: 0.005, decay: 0.2, sustain: 0 }
        }).toDestination();
        soundsReady = true;
    }

    function playEatSound() {
        if (soundsReady) {
            synth.triggerAttackRelease('C5', '8n');
        }
    }

    function playGameOverSound() {
        if (soundsReady) {
            crashSynth.triggerAttackRelease('4n');
        }
    }

    // --- Game Initialization ---
    function init() {
        snake = [
            { x: 10, y: 10 },
            { x: 9, y: 10 },
            { x: 8, y: 10 }
        ];
        snake.color = COLORS[Math.floor(Math.random() * COLORS.length)];
        score = 0;
        direction = 'RIGHT';
        nextDirection = 'RIGHT';
        isGameOver = false;
        currentSpeed = INITIAL_SPEED;

        spawnFood();
        updateScores();

        startScreen.style.display = 'none';
        gameOverScreen.style.display = 'none';

        // Clear any previous game loop
        if (gameLoopTimeout) clearTimeout(gameLoopTimeout);
        gameLoop();
    }

    // --- Main Game Loop ---
    function gameLoop() {
        if (isGameOver) return;
        update();
        draw();
        gameLoopTimeout = setTimeout(gameLoop, currentSpeed);
    }

    // --- Drawing Functions ---
    function draw() {
        // Clear canvas
        ctx.fillStyle = '#2C3E50';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw food
        drawCircle(food.x, food.y, food.color, TILE_SIZE / 2);

        // --- Draw Snake Body ---
        for (let i = snake.length - 1; i > 0; i--) {
            const segment = snake[i];
            const prevSegment = snake[i - 1];

            const maxRadius = TILE_SIZE / 2 * 1.1;
            const minRadius = TILE_SIZE / 4;
            const radius = Math.max(maxRadius - (i / snake.length) * (maxRadius - minRadius), minRadius);
            
            ctx.beginPath();
            ctx.moveTo(segment.x * TILE_SIZE + TILE_SIZE / 2, segment.y * TILE_SIZE + TILE_SIZE / 2);
            ctx.lineTo(prevSegment.x * TILE_SIZE + TILE_SIZE / 2, prevSegment.y * TILE_SIZE + TILE_SIZE / 2);
            ctx.strokeStyle = snake.color;
            ctx.lineWidth = radius * 2;
            ctx.lineCap = 'round';
            ctx.stroke();
        }
        
        // --- Draw Snake Head with Eyes ---
        const head = snake[0];
        const headRadius = (TILE_SIZE / 2 * 1.1);
        drawCircle(head.x, head.y, snake.color, headRadius);

        const eyeRadius = TILE_SIZE / 10;
        const eyeOffset = TILE_SIZE / 4;
        let eye1_x, eye1_y, eye2_x, eye2_y;
        const headCenterX = head.x * TILE_SIZE + TILE_SIZE / 2;
        const headCenterY = head.y * TILE_SIZE + TILE_SIZE / 2;

        switch(direction) {
            case 'RIGHT':
                eye1_x = headCenterX + eyeOffset / 2; eye1_y = headCenterY - eyeOffset;
                eye2_x = headCenterX + eyeOffset / 2; eye2_y = headCenterY + eyeOffset;
                break;
            case 'LEFT':
                eye1_x = headCenterX - eyeOffset / 2; eye1_y = headCenterY - eyeOffset;
                eye2_x = headCenterX - eyeOffset / 2; eye2_y = headCenterY + eyeOffset;
                break;
            case 'UP':
                eye1_x = headCenterX - eyeOffset; eye1_y = headCenterY - eyeOffset / 2;
                eye2_x = headCenterX + eyeOffset; eye2_y = headCenterY - eyeOffset / 2;
                break;
            case 'DOWN':
                eye1_x = headCenterX - eyeOffset; eye1_y = headCenterY + eyeOffset / 2;
                eye2_x = headCenterX + eyeOffset; eye2_y = headCenterY + eyeOffset / 2;
                break;
        }

        ctx.fillStyle = '#1a2531'; // Dark color for eyes
        ctx.beginPath(); ctx.arc(eye1_x, eye1_y, eyeRadius, 0, 2 * Math.PI); ctx.fill();
        ctx.beginPath(); ctx.arc(eye2_x, eye2_y, eyeRadius, 0, 2 * Math.PI); ctx.fill();
    }

    function drawCircle(x, y, color, radius) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, radius, 0, 2 * Math.PI);
        ctx.fill();
    }

    // --- Game Logic Update ---
    function update() {
        direction = nextDirection;
        const head = { x: snake[0].x, y: snake[0].y };

        switch (direction) {
            case 'UP': head.y--; break;
            case 'DOWN': head.y++; break;
            case 'LEFT': head.x--; break;
            case 'RIGHT': head.x++; break;
        }

        // --- Collision Detection ---
        // Wall collision
        if (head.x < 0 || head.x >= GRID_WIDTH || head.y < 0 || head.y >= GRID_HEIGHT) {
            endGame();
            return;
        }
        // Self collision
        for (let i = 1; i < snake.length; i++) {
            if (head.x === snake[i].x && head.y === snake[i].y) {
                endGame();
                return;
            }
        }

        snake.unshift(head);

        // --- Eating Food ---
        if (head.x === food.x && head.y === food.y) {
            score += 10;
            snake.color = food.color; // The core mechanic!
            currentSpeed = Math.max(50, currentSpeed - SPEED_INCREMENT); // Speed up
            playEatSound();
            spawnFood();
            updateScores();
        } else {
            snake.pop();
        }
    }

    // --- Utility Functions ---
    function spawnFood() {
        let position;
        do {
            position = {
                x: Math.floor(Math.random() * GRID_WIDTH),
                y: Math.floor(Math.random() * GRID_HEIGHT)
            };
        } while (isPositionOnSnake(position));

        food = {
            ...position,
            color: COLORS[Math.floor(Math.random() * COLORS.length)]
        };
    }

    function isPositionOnSnake(pos) {
        return snake.some(segment => segment.x === pos.x && segment.y === pos.y);
    }

    function updateScores() {
        scoreEl.textContent = `SCORE: ${score}`;
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('chromaSnakeHighScore', highScore);
        }
        highScoreEl.textContent = `HIGH: ${highScore}`;
    }

    function endGame() {
        isGameOver = true;
        playGameOverSound();
        finalScoreEl.textContent = `Final Score: ${score}`;
        gameOverScreen.style.display = 'flex';
    }

    // --- Event Listeners ---
    document.addEventListener('keydown', e => {
        switch (e.key) {
            case 'ArrowUp':
                if (direction !== 'DOWN') nextDirection = 'UP';
                break;
            case 'ArrowDown':
                if (direction !== 'UP') nextDirection = 'DOWN';
                break;
            case 'ArrowLeft':
                if (direction !== 'RIGHT') nextDirection = 'LEFT';
                break;
            case 'ArrowRight':
                if (direction !== 'LEFT') nextDirection = 'RIGHT';
                break;
        }
    });

    startButton.addEventListener('click', () => {
        // Resume audio context on user interaction
        if (soundsReady && Tone.context.state !== 'running') {
            Tone.context.resume();
        }
        init();
    });

    playAgainButton.addEventListener('click', init);

    // --- Initial Setup ---
    updateScores();
</script>

</body>
</html>

