<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Chroma-Snake Pro</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        :root {
            --dark-bg: #1a1a2a;
            --container-bg: #2a2a3a;
            --button-bg: linear-gradient(145deg, #3a3a4a, #2a2a3a);
            --button-active-bg: linear-gradient(145deg, #2a2a3a, #3a3a4a);
            --glow-color: rgba(0, 255, 255, 0.7);
        }
        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            background-color: var(--dark-bg);
            font-family: 'Poppins', sans-serif;
            color: #fff;
        }
        .center-container {
            width: 100%; height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas { 
            display: block; 
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }

        /* --- UI Overlay --- */
        .ui-overlay {
            position: absolute; top: 0; left: 0; right: 0;
            padding: 20px; box-sizing: border-box;
            display: flex; justify-content: space-between;
            font-size: clamp(1rem, 3vw, 1.5rem);
            font-weight: 700;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.7);
            pointer-events: none;
        }
        #score-value {
             transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .score-pop {
            transform: scale(1.5);
        }

        /* --- Mobile Layout --- */
        .mobile-wrapper {
            display: none; width: 100%; height: 100%;
            background-color: var(--dark-bg);
            flex-direction: column;
            justify-content: center; align-items: center;
            padding: 10px; box-sizing: border-box;
        }
        .mobile-canvas-container {
            width: 100%; height: 65%;
            display: flex; justify-content: center; align-items: center;
            padding-bottom: 10px; box-sizing: border-box;
            overflow: hidden;
        }
        .mobile-controls {
            width: 100%; height: 35%;
            max-width: 400px;
            display: grid;
            grid-template-areas:
                ". up ."
                "left center right"
                ". down .";
            grid-gap: 15px;
            flex-shrink: 0;
            /* FIX: Robust centering for the control pad */
            margin: 0 auto;
        }
        .touch-btn {
            background: var(--button-bg);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 25px;
            box-shadow: 5px 5px 10px #1e1e2e, -5px -5px 10px #363646;
            cursor: pointer; aspect-ratio: 1 / 1;
            display: flex; justify-content: center; align-items: center;
            font-size: 2.5rem;
            color: #ccc;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            transition: all 0.1s ease;
        }
        .touch-btn:active {
            background: var(--button-active-bg);
            box-shadow: inset 5px 5px 10px #1e1e2e, inset -5px -5px 10px #363646;
            transform: scale(0.95);
        }
        #btn-up { grid-area: up; } #btn-down { grid-area: down; }
        #btn-left { grid-area: left; } #btn-right { grid-area: right; }

        /* --- PC Game Container --- */
        .pc-container {
            display: none;
            border-radius: 10px;
            position: relative;
        }

        /* --- Modals & Animations --- */
        .modal {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; text-align: center;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px) saturate(120%);
            -webkit-backdrop-filter: blur(10px) saturate(120%);
            animation: fadeIn 0.5s ease;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        
        .modal-content {
            background: rgba(42, 42, 58, 0.8);
            padding: 40px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }
        
        .modal h1 {
            font-size: clamp(2.5rem, 10vw, 4rem);
            margin: 0 0 20px 0;
            font-weight: 700;
            letter-spacing: 2px;
            background: linear-gradient(90deg, #FFD300, #FF5470, #BC00DD);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .modal p { font-size: 1.5rem; margin: 20px 0; font-weight: 600; }
        .button {
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: 'Poppins', sans-serif;
            font-weight: 700;
            color: #fff;
            background: var(--button-bg);
            border: none;
            border-radius: 15px;
            cursor: pointer;
            box-shadow: 5px 5px 10px #1e1e2e, -5px -5px 10px #363646;
            transition: all 0.2s ease-in-out;
            margin: 10px;
        }
        .button:hover { transform: translateY(-3px) scale(1.05); }
        .button:active { transform: translateY(2px) scale(0.98); }
    </style>
</head>
<body>

<div class="center-container">
    <div id="mobileWrapper" class="mobile-wrapper">
        <div class="mobile-canvas-container">
            <canvas id="mobileGameCanvas"></canvas>
        </div>
        <div class="mobile-controls">
            <div id="btn-up" class="touch-btn">▲</div>
            <div id="btn-left" class="touch-btn">◄</div>
            <div id="btn-right" class="touch-btn">►</div>
            <div id="btn-down" class="touch-btn">▼</div>
        </div>
    </div>

    <div id="pcContainer" class="pc-container">
        <canvas id="gameCanvas"></canvas>
        <div class="ui-overlay">
            <div id="score">SCORE: <span id="score-value">0</span></div>
            <div id="highScore">HIGH: <span id="highscore-value">0</span></div>
        </div>
    </div>
</div>

<div id="deviceChoiceScreen" class="modal">
    <div class="modal-content">
        <h1>Chroma-Snake</h1>
        <p>Choose your device</p>
        <div>
            <button id="pcButton" class="button">PC</button>
            <button id="mobileButton" class="button">Mobile</button>
        </div>
    </div>
</div>

<div id="gameOverScreen" class="modal" style="display: none;">
    <div class="modal-content">
        <h1>Game Over</h1>
        <p id="finalScore"></p>
        <button id="playAgainButton" class="button">Play Again</button>
    </div>
</div>

<script>
    // --- Global Setup ---
    let canvas, ctx, scoreValueEl, highScoreValueEl, isMobile;
    let particles = [], backgroundParticles = [];
    let wavePhase = 0; // For snake wave animation
    const deviceChoiceScreen = document.getElementById('deviceChoiceScreen');
    const pcButton = document.getElementById('pcButton');
    const mobileButton = document.getElementById('mobileButton');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScoreEl = document.getElementById('finalScore');
    const playAgainButton = document.getElementById('playAgainButton');
    
    // --- Game Constants & State ---
    const COLORS = ["#FFD300", "#FF5470", "#4D94FF", "#00F9B8", "#BC00DD", "#FFFFFF"];
    const BIG_FOOD_THRESHOLD = 5;
    let TILE_SIZE, GRID_WIDTH, GRID_HEIGHT;
    let snake, food, bigFood, isBigFoodActive, foodEatenCount, score, highScore, direction, nextDirection, isGameOver;
    let lastTime = 0, timeSinceLastMove = 0;
    // FIX: Increased initial speed for better responsiveness
    let initialGameSpeed = 150; 
    let gameSpeed = initialGameSpeed;
    highScore = localStorage.getItem('chromaSnakeProHighScore') || 0;

    // --- Sound & Haptics ---
    let synth, crashSynth, soundsReady = false;
    function setupAudio() {
        if (typeof Tone !== 'undefined' && !soundsReady) {
            if (Tone.context.state !== 'running') { Tone.context.resume(); }
            synth = new Tone.Synth({ oscillator: { type: 'fatsawtooth' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.2 } }).toDestination();
            crashSynth = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
            soundsReady = true;
        }
    }
    function playEatSound() { if (soundsReady) synth.triggerAttackRelease('C5', '16n'); }
    function playGameOverSound() { if (soundsReady) crashSynth.triggerAttackRelease('8n'); }
    function triggerVibration(duration) { if (isMobile && 'vibrate' in navigator) navigator.vibrate(duration); }

    // --- Particle System ---
    class Particle {
        constructor(x, y, color, size, speed, life) {
            this.x = x; this.y = y; this.color = color;
            this.size = Math.random() * size + 2;
            this.life = life; this.initialLife = life;
            this.vx = (Math.random() - 0.5) * speed;
            this.vy = (Math.random() - 0.5) * speed;
        }
        update() { this.x += this.vx; this.y += this.vy; this.life--; }
        draw(context) {
            context.save();
            context.globalAlpha = this.life / this.initialLife;
            context.fillStyle = this.color;
            context.beginPath();
            context.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            context.fill();
            context.restore();
        }
    }
    function createExplosion(x, y, color) {
        for (let i = 0; i < 30; i++) {
            particles.push(new Particle(x, y, color, 5, 4, 50));
        }
    }
    function createBackgroundParticles() {
        for (let i = 0; i < 50; i++) {
            backgroundParticles.push(new Particle(Math.random() * canvas.width, Math.random() * canvas.height, 'rgba(255,255,255,0.1)', 3, 0.5, 500 + Math.random() * 500));
        }
    }

    // --- Device Selection ---
    pcButton.addEventListener('click', () => setupGame(false));
    mobileButton.addEventListener('click', () => setupGame(true));
    
    function setupGame(mobile) {
        isMobile = mobile;
        setupAudio();
        deviceChoiceScreen.style.display = 'none';

        if (isMobile) {
            document.getElementById('mobileWrapper').style.display = 'flex';
            const container = document.querySelector('.mobile-canvas-container');
            canvas = document.getElementById('mobileGameCanvas');
            GRID_WIDTH = 18; GRID_HEIGHT = 18;
            const containerSize = Math.min(container.clientWidth, container.clientHeight);
            TILE_SIZE = Math.floor(containerSize / GRID_WIDTH);
        } else {
            document.getElementById('pcContainer').style.display = 'block';
            canvas = document.getElementById('gameCanvas');
            scoreValueEl = document.getElementById('score-value');
            highScoreValueEl = document.getElementById('highscore-value');
            GRID_WIDTH = 30; GRID_HEIGHT = 20;
            TILE_SIZE = 25;
        }
        ctx = canvas.getContext('2d');
        canvas.width = GRID_WIDTH * TILE_SIZE;
        canvas.height = GRID_HEIGHT * TILE_SIZE;
        
        createBackgroundParticles();
        init();
    }

    // --- Game Initialization ---
    function init() {
        snake = [{ x: 10, y: 10 }, { x: 9, y: 10 }, { x: 8, y: 10 }];
        snake.color = COLORS[Math.floor(Math.random() * COLORS.length)];
        score = 0;
        direction = 'RIGHT'; nextDirection = 'RIGHT';
        isGameOver = false; isBigFoodActive = false; foodEatenCount = 0;
        gameSpeed = initialGameSpeed;
        wavePhase = 0; 
        spawnFood();
        updateScores();
        gameOverScreen.style.display = 'none';
        
        lastTime = 0; timeSinceLastMove = 0;
        requestAnimationFrame(gameLoop);
    }

    // --- Main Game Loop (requestAnimationFrame) ---
    function gameLoop(currentTime) {
        if (isGameOver) return;
        requestAnimationFrame(gameLoop);
        const deltaTime = currentTime - lastTime;
        lastTime = currentTime;
        timeSinceLastMove += deltaTime;

        if (timeSinceLastMove > gameSpeed) {
            timeSinceLastMove %= gameSpeed; // Use modulo to prevent time loss and maintain rhythm
            update();
        }
        draw();
    }
    
    // --- Drawing ---
    function draw() {
        wavePhase += 0.1;
        ctx.fillStyle = '#1a1a2a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        backgroundParticles.forEach((p, index) => {
            if (p.life <= 0 || p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
                backgroundParticles[index] = new Particle(Math.random() * canvas.width, Math.random() * canvas.height, 'rgba(255,255,255,0.1)', 3, 0.5, 500 + Math.random() * 500);
            }
            p.update(); p.draw(ctx);
        });
        
        drawWavingSnake();

        drawGlowingOrb(food.x, food.y, TILE_SIZE / 2, food.color);
        if (isBigFoodActive) {
            drawGlowingOrb(bigFood.x + 0.5, bigFood.y + 0.5, TILE_SIZE, bigFood.color);
        }

        particles.forEach((p, index) => {
            if (p.life <= 0) particles.splice(index, 1);
            else { p.update(); p.draw(ctx); }
        });
    }
    
    function drawGlowingOrb(x, y, radius, color) {
        const centerX = x * TILE_SIZE + TILE_SIZE / 2;
        const centerY = y * TILE_SIZE + TILE_SIZE / 2;
        ctx.save();
        ctx.shadowBlur = 20;
        ctx.shadowColor = color;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    function drawWavingSnake() {
        if (snake.length < 2) return;
        
        const waveAmplitude = TILE_SIZE * 0.25;
        const waveFrequency = 0.6;
        
        for (let i = snake.length - 1; i > 0; i--) {
            const currentSeg = { x: snake[i].x * TILE_SIZE + TILE_SIZE / 2, y: snake[i].y * TILE_SIZE + TILE_SIZE / 2 };
            const nextSeg = { x: snake[i - 1].x * TILE_SIZE + TILE_SIZE / 2, y: snake[i - 1].y * TILE_SIZE + TILE_SIZE / 2 };
            
            const midPoint = { x: (currentSeg.x + nextSeg.x) / 2, y: (currentSeg.y + nextSeg.y) / 2 };
            const dx = nextSeg.x - currentSeg.x;
            const dy = nextSeg.y - currentSeg.y;
            const distance = Math.max(1, Math.sqrt(dx*dx + dy*dy));
            const perpX = -dy / distance;
            const perpY = dx / distance;
            const offset = Math.sin(i * waveFrequency + wavePhase) * waveAmplitude;
            const controlPoint = { x: midPoint.x + perpX * offset, y: midPoint.y + perpY * offset };

            const maxRadius = TILE_SIZE / 2.2;
            const minRadius = TILE_SIZE / 6;
            const radius = Math.max(minRadius, maxRadius - (i / snake.length) * (maxRadius - minRadius));
            
            ctx.beginPath();
            ctx.moveTo(currentSeg.x, currentSeg.y);
            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, nextSeg.x, nextSeg.y);

            ctx.strokeStyle = LightenDarkenColor(snake.color, -60);
            ctx.lineWidth = radius * 2.2;
            ctx.lineCap = 'round';
            ctx.stroke();

            ctx.strokeStyle = snake.color;
            ctx.lineWidth = radius * 1.8;
            ctx.stroke();

            ctx.strokeStyle = LightenDarkenColor(snake.color, 50);
            ctx.lineWidth = radius * 0.8;
            ctx.stroke();
        }
        
        const head = snake[0];
        drawGlowingOrb(head.x, head.y, TILE_SIZE/2.2, snake.color);
        
        if (Math.random() > 0.5) {
            particles.push(new Particle(head.x * TILE_SIZE + TILE_SIZE/2, head.y * TILE_SIZE + TILE_SIZE/2, snake.color, 3, 1, 30));
        }
    }

    // --- Game Logic Update ---
    function update() {
        direction = nextDirection;
        const head = { x: snake[0].x, y: snake[0].y };
        switch (direction) {
            case 'UP': head.y--; break; case 'DOWN': head.y++; break;
            case 'LEFT': head.x--; break; case 'RIGHT': head.x++; break;
        }
        if (head.x < 0 || head.x >= GRID_WIDTH || head.y < 0 || head.y >= GRID_HEIGHT || snake.some(seg => seg.x === head.x && seg.y === head.y)) {
            triggerVibration([100, 50, 100]); endGame(); return;
        }
        snake.unshift(head);
        if (isBigFoodActive && head.x >= bigFood.x && head.x < bigFood.x + 2 && head.y >= bigFood.y && head.y < bigFood.y + 2) {
            handleEat(bigFood.color, 50, 5);
            isBigFoodActive = false; foodEatenCount = 0;
            createExplosion((bigFood.x + 1) * TILE_SIZE, (bigFood.y + 1) * TILE_SIZE, bigFood.color);
        } else if (head.x === food.x && head.y === food.y) {
            handleEat(food.color, 10, 1);
            foodEatenCount++;
            if (isBigFoodActive) { isBigFoodActive = false; foodEatenCount = 0; }
            if (foodEatenCount >= BIG_FOOD_THRESHOLD) { isBigFoodActive = true; spawnBigFood(); }
            createExplosion((food.x + 0.5) * TILE_SIZE, (food.y + 0.5) * TILE_SIZE, food.color);
        } else {
            snake.pop();
        }
    }

    function handleEat(color, scoreIncrease, lengthIncrease) {
        score += scoreIncrease;
        for(let i=0; i<lengthIncrease; i++) snake.push({ ...snake[snake.length - 1] });
        snake.color = color;
        gameSpeed = Math.max(70, gameSpeed - 3);
        playEatSound(); triggerVibration(50);
        updateScores();
        spawnFood();
    }
    
    // --- Utilities ---
    function spawnFood() {
        let position;
        do { position = { x: Math.floor(Math.random() * GRID_WIDTH), y: Math.floor(Math.random() * GRID_HEIGHT) };
        } while (snake.some(seg => seg.x === position.x && seg.y === position.y));
        food = { ...position, color: COLORS[Math.floor(Math.random() * COLORS.length)] };
    }
    function spawnBigFood() {
        let position;
        do { position = { x: Math.floor(Math.random() * (GRID_WIDTH - 2)), y: Math.floor(Math.random() * (GRID_HEIGHT - 2)) };
        } while (snake.some(seg => seg.x >= position.x && seg.x < position.x + 2 && seg.y >= position.y && seg.y < position.y + 2) || (position.x === food.x && position.y === food.y));
        bigFood = { ...position, color: COLORS[Math.floor(Math.random() * COLORS.length)] };
    }
    function updateScores() {
        if (isMobile) return;
        scoreValueEl.textContent = score;
        scoreValueEl.parentElement.classList.add('score-pop');
        setTimeout(() => scoreValueEl.parentElement.classList.remove('score-pop'), 200);
        
        if (score > highScore) { 
            highScore = score; 
            localStorage.setItem('chromaSnakeProHighScore', highScore); 
        }
        highScoreValueEl.textContent = highScore;
    }
    function endGame() {
        isGameOver = true;
        playGameOverSound();
        const finalHighScore = Math.max(score, highScore);
        finalScoreEl.textContent = `Score: ${score} | High: ${finalHighScore}`;
        gameOverScreen.style.display = 'flex';
    }
    function handleInput(newDirection) {
        if (isGameOver) return;
        const opposite = { 'UP': 'DOWN', 'DOWN': 'UP', 'LEFT': 'RIGHT', 'RIGHT': 'LEFT' };
        if (direction !== opposite[newDirection]) {
            nextDirection = newDirection;
        }
    }
    function LightenDarkenColor(col, amt) {
        let usePound = false;
        if (col[0] == "#") { col = col.slice(1); usePound = true; }
        let num = parseInt(col, 16);
        let r = (num >> 16) + amt;
        if (r > 255) r = 255; else if (r < 0) r = 0;
        let b = ((num >> 8) & 0x00FF) + amt;
        if (b > 255) b = 255; else if (b < 0) b = 0;
        let g = (num & 0x0000FF) + amt;
        if (g > 255) g = 255; else if (g < 0) g = 0;
        return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16).padStart(6, '0');
    }

    // --- Input Listeners ---
    document.addEventListener('keydown', e => { if(isMobile) return; switch (e.key) { case 'ArrowUp': handleInput('UP'); break; case 'ArrowDown': handleInput('DOWN'); break; case 'ArrowLeft': handleInput('LEFT'); break; case 'ArrowRight': handleInput('RIGHT'); break; } });
    ['btn-up', 'btn-down', 'btn-left', 'btn-right'].forEach(id => {
        const btn = document.getElementById(id);
        const direction = id.split('-')[1].toUpperCase();
        btn.addEventListener('click', () => handleInput(direction));
    });
    playAgainButton.addEventListener('click', () => {
        gameOverScreen.style.display = 'none';
        init();
    });
</script>
</body>
</html>

